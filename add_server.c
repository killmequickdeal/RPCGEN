/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "add.h"
#include <chrono>
#include <ctime>
#include <string>
#include <stdio.h>
#include <algorithm>
#include <iostream>
#include <dirent.h>
#include <thread>
#include <mutex>

bool_t
dateandtime_1_svc(char **result, struct svc_req *rqstp)
{
  std::cout << "DateAndTime	called" << std::endl;
  bool_t retval = 1;
  //get the current clock time, convert it to ctime since its easy to convert
  //from ctime to string, return.
  auto time = std::chrono::system_clock::now();
  std::time_t t = std::chrono::system_clock::to_time_t(time);
  *result = (char *) malloc(256);
  strcpy(*result, std::ctime(&t)); 

	return retval;
}

bool_t
sort_1_svc(int_ptr arg1, int_ptr *result,  struct svc_req *rqstp)
{
  std::cout << "Sort called" << std::endl;
	bool_t retval = 1;
  // sort the list from arg1, copy into result 
  int size = arg1.int_ptr_len;
  result->int_ptr_len = size;
  result->int_ptr_val = (int*)malloc(sizeof(int)*size);
  for(int i = 0; i < size; i++) {
    for(int j = 0; j < size; j++) {
      if (arg1.int_ptr_val[i] < arg1.int_ptr_val[j]) {
        int tmp = arg1.int_ptr_val[j];
        arg1.int_ptr_val[j] = arg1.int_ptr_val[i];
        arg1.int_ptr_val[i] = tmp;   
      } 
    } 
  }  
  for(int i = 0; i < size; i++) {
    result->int_ptr_val[i] = arg1.int_ptr_val[i];
  }
	return retval;
}

bool_t
list_1_svc(char **result, struct svc_req *rqstp)
{
  std::cout << "List called" << std::endl;
	bool_t retval = 1;
  //use c style directory access as c++ doesn't add an easy one until c++17
  //which isnt available on server

  //while there is still a file to read in directory, add its name to string
  //copy the string into result
  std::string s = "";
  DIR* d = opendir(".");
  struct dirent * file;
  while((file = readdir(d)) != NULL) {
    s += file->d_name;
    s += "\n";
  }  
  closedir(d);
  // note this is a magic number and WOULD break if enough files are in the 
  // directory. I was having issues with using sizeof(s), etc...needs further 
  // research, could be related to number of \n"
  *result = (char*) malloc(1000);
 
  strcpy(*result, s.c_str());
	return retval;
}

bool_t
matrixmultiply_1_svc(Matrix arg1, Matrix arg2, Matrix *result,  struct svc_req *rqstp)
{
  std::cout << "MatrixMultiply Called" << std::endl;
	bool_t retval = 1;
  // simple n^3 matrix multiply. Somewhat optimized as ikj loop is the best
  // for memory locality in a 1D array. Could be further optimized via registers, etc.
  result->size1= arg1.size1;
  result->size2= arg2.size2;
  result->matrix.int_ptr_len = result->size1*result->size2;
  result->matrix.int_ptr_val = (int*)malloc(result->matrix.int_ptr_len*sizeof(int));
 
  for (int loc = 0; loc < result->matrix.int_ptr_len; loc++) {
    result->matrix.int_ptr_val[loc] = 0;
  }

  for (int i = 0; i < arg1.size1; ++i) {
    for (int k = 0; k < arg2.size2; ++k) {
      for (int j = 0; j < arg1.size2; j++) {
        result->matrix.int_ptr_val[i * arg2.size2 + j] += arg1.matrix.int_ptr_val[i*arg2.size2+k] * arg2.matrix.int_ptr_val[k * arg2.size2 + j];
      }
    }
  }
	return retval;
}

bool_t
reverseencryptedecho_1_svc(char *arg1, char **result,  struct svc_req *rqstp)
{
  std::cout << "ReverseEncryptedEcho Called" << std::endl;
  bool_t retval = 1;
  // very simple XOR cipher https://en.wikipedia.org/wiki/XOR_cipher
  // essentially just do an XOR between the key with each character of the string.
  // Decryption is simple as you just apply the operation again with the same key.
  char key = 'K';
  std::string s = arg1;
  
  std::reverse(s.begin(), s.end());
  for (int i = 0; i < s.size(); i++) {
    s[i] ^= key;
  }  
  *result = (char*) malloc(sizeof(s));
  strcpy(*result, s.c_str()); 
	return retval;
}

int
add_prog_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	return 1;
}
